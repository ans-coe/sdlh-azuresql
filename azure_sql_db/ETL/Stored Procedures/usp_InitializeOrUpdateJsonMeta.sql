/*
===============================================================
Author: Andrei Dumitru
Created: 2022-11-01
Name: usp_InitializeOrUpdateJsonMeta
Description:	 
   
===============================================================
Change History

Date        Name            Description
2022-11-01  Andrei Dumitru  Initial create
2023-11-01  Darren Price    Brought inline with data standards
===============================================================
*/
CREATE PROCEDURE [ETL].[usp_InitializeOrUpdateJsonMeta]
    -- PIPELINE TRIGGER DATETIME TO CALCULATE HIERARCHICAL NAME SPACE
    @VAR_PIPELINE_CURRENT_DATETIME DATETIME,

    -- PIPELINE PARAMETERS
    @PARAM_JSON_TRIGGER VARCHAR(MAX),
    @PARAM_PIPELINE_NAME VARCHAR(500),
    @PARAM_OBJECT_TYPE VARCHAR(100)

AS
BEGIN
    SET NOCOUNT ON;

    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'JsonMetadata')
    BEGIN
        CREATE TABLE [ETL].[JsonMetadata](
            [OBJECT_ID] [int] IDENTITY(1,1) NOT NULL,
            [OBJECT_NAME] [varchar](500) NOT NULL,
            [OBJECT_TYPE] [varchar](100) NOT NULL,
            [PIPELINE_NAME] [varchar](500) NOT NULL,
            [TRIGGERS_INFO] [varchar](max) NOT NULL,
            [BATCH_FREQUENCY] [varchar](100) NOT NULL,
            [LOAD_TYPE] [varchar](500) NOT NULL,
            [ADLS_PATHS] [varchar](max) NOT NULL,
            [OBJECT_PARAMETERS] [varchar](max) NOT NULL
        ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
        ALTER TABLE [ETL].[JsonMetadata] ADD PRIMARY KEY CLUSTERED 
        (
            [OBJECT_NAME] ASC
        )WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
    END;

    -- CREATING IN-MEMORY TABLE FOR STORING PARAMETERS ABOUT THE OBJECT WE WANT TO MIGRATE. 
    WITH cte_object_params AS(
        SELECT T.TABLE_NAME AS [TABLE_NAME],
            T.PRIMARY_KEYS AS [PRIMARY_KEYS],
            V.VERSION_NUMBER AS [VERSION_NUMBER],
            T.COLUMNS_META AS [COLUMNS_META],
            (SELECT 
            --CONCAT('select c.* , tc.commit_time from changetable(changes [', T.SCHEMA_NAME, '].[', T.TABLE_NAME ,'], 0) c join sys.dm_tran_commit_table tc on c.sys_change_version = tc.commit_ts') AS [CHANGE_TRACKING_TABLE_QUERY], 
            MAX(SYS_CHANGE_VERSION_VALUE) AS MAX_SYS_CHANGE_VERSION
            FROM ETL.SourceIncrementalLoad SIL 
            WHERE T.TABLE_NAME = SIL.TABLE_NAME FOR JSON PATH) AS OBJECT_LOAD_PARAMETERS,
            (SELECT C.COLUMN_NAME AS COLUMN_NAME,
            C.PARQUET_COLUMN_NAME AS PARQUET_COLUMN_NAME, 
            C.IS_NULLABLE AS IS_NULLABLE,
            C.DATA_TYPE AS DATA_TYPE,
            C.CHARACTER_MAXIMUM_LENGTH AS CHARACTER_MAXIMUM_LENGTH,
            C.COLLATION_NAME AS COLLATION_NAME

        FROM ETL.SourceColumn C
        WHERE C.TABLE_NAME = T.TABLE_NAME
        FOR JSON PATH) AS INFORMATION_SCHEMA
        
        FROM [ETL].[SourceTable] T, [ETL].[SourceSchemaVersion] V, [ETL].[SourceIncrementalLoad] SIL
        WHERE V.OBJECT_NAME = T.TABLE_NAME 
        AND SIL.TABLE_NAME = T.TABLE_NAME
    ),

    cte_adls_paths AS (
    SELECT S.TABLE_NAME,
        (SELECT distinct 'raw' AS FP0, 
            CONCAT(REPLACE(REPLACE(REPLACE(T.SOURCE_SYSTEM,'.','_'), '-','_'), '\', '_'),'/', T.DATABASE_NAME,'/', T.SCHEMA_NAME,'/',T.TABLE_NAME, '/', V.VERSION_NUMBER, '/') AS FP1
            -- CASE 
            -- WHEN BATCH_FREQUENCY = 'Minute' THEN CONCAT(DATEPART(year, @VAR_PIPELINE_CURRENT_DATETIME),'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME,'MM') ,'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME, 'dd'),'/', FORMAT([ETL].[udf_RoundTime](@VAR_PIPELINE_CURRENT_DATETIME, 30), 'hh'),'/', FORMAT([ETL].[udf_RoundTime](@VAR_PIPELINE_CURRENT_DATETIME, 30), 'mm'))
            -- WHEN BATCH_FREQUENCY = 'Hour' THEN CONCAT(DATEPART(year, @VAR_PIPELINE_CURRENT_DATETIME),'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME,'MM') ,'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME, 'dd'),'/', FORMAT([ETL].[udf_RoundTime](@VAR_PIPELINE_CURRENT_DATETIME, 30), 'hh'))
            -- WHEN BATCH_FREQUENCY = 'Day' THEN CONCAT(DATEPART(year, @VAR_PIPELINE_CURRENT_DATETIME),'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME,'MM') ,'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME, 'dd'))
            -- WHEN BATCH_FREQUENCY = 'Month' THEN CONCAT(DATEPART(year, @VAR_PIPELINE_CURRENT_DATETIME),'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME,'MM'))
            -- ELSE CONCAT(DATEPART(year, @VAR_PIPELINE_CURRENT_DATETIME),'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME,'MM') ,'/', FORMAT(@VAR_PIPELINE_CURRENT_DATETIME, 'dd'))
            -- END AS HNS
            FROM ETL.SourceTable T, ETL.SourceSchemaVersion V WHERE T.TABLE_NAME = S.TABLE_NAME AND V.OBJECT_NAME = T.TABLE_NAME FOR JSON PATH) AS [raw], 
            (SELECT 'enriched' as FP0, CONCAT(T.SERVERLESS_SQL_POOL_DATABASE,'/',T.SERVERLESS_SQL_POOL_SCHEMA ,'/',T.TABLE_NAME, '/' ) AS FP1 FROM ETL.SourceTable T WHERE T.TABLE_NAME = S.TABLE_NAME FOR JSON PATH) as [staged]
    FROM ETL.SourceTable S)

    MERGE ETL.JsonMetadata AS target
    USING (
    SELECT 
        CONCAT(REPLACE(REPLACE(REPLACE(T.SOURCE_SYSTEM,'.','_'), '-','_'), '\', '_'), '_',T.DATABASE_NAME,'_', T.SCHEMA_NAME, '_',T.TABLE_NAME) AS OBJECT_NAME, 
        OBJECT_TYPE AS OBJECT_TYPE,
        --CASE WHEN LOAD_TYPE = 'FULL_LOAD' THEN CONCAT(LOWER(OBJECT_TYPE),'_lakehouse_full_load_pipeline')
        --    WHEN LOAD_TYPE = 'CHANGE_TRACKING' THEN CONCAT(LOWER(OBJECT_TYPE),'_lakehouse_change_tracking_incremental_load_pipeline')
        --    WHEN LOAD_TYPE = 'HIGH_WATERMARK' THEN CONCAT(LOWER(OBJECT_TYPE),'_lakehouse_high_watermark_incremental_load_pipeline')
        --    END AS 'PIPELINE_NAME',
        @PARAM_PIPELINE_NAME AS PIPELINE_NAME,
        @PARAM_JSON_TRIGGER AS TRIGGERS_INFO,
        BATCH_FREQUENCY AS BATCH_FREQUENCY,
        LOAD_TYPE AS LOAD_TYPE,
        (SELECT [raw], [staged] FROM cte_adls_paths ADLS WHERE ADLS.TABLE_NAME = T.TABLE_NAME FOR JSON PATH) AS ADLS_PATHS,

        (SELECT distinct T.SOURCE_SYSTEM AS SOURCE_SYSTEM, T.DATABASE_NAME AS DATABASE_NAME, T.SCHEMA_NAME AS SCHEMA_NAME, OBP.[TABLE_NAME],T.SOURCE_SYSTEM_CONNECTION_STRING,OBP.[PRIMARY_KEYS],OBP.[VERSION_NUMBER],OBP.[COLUMNS_META],OBP.[OBJECT_LOAD_PARAMETERS], T.[SERVERLESS_SQL_POOL_DATABASE], T.[SERVERLESS_SQL_POOL_SCHEMA] ,OBP.[INFORMATION_SCHEMA] FROM cte_object_params OBP WHERE T.TABLE_NAME = OBP.TABLE_NAME FOR JSON PATH ) AS OBJECT_PARAMETERS
    FROM ETL.SourceTable T) AS source
    ON (target.OBJECT_NAME = source.OBJECT_NAME)
    WHEN MATCHED THEN
        UPDATE SET 
            target.OBJECT_TYPE = source.OBJECT_TYPE,
            target.PIPELINE_NAME = source.PIPELINE_NAME,
            target.TRIGGERS_INFO = source.TRIGGERS_INFO,
            target.BATCH_FREQUENCY = source.BATCH_FREQUENCY,
            target.LOAD_TYPE = source.LOAD_TYPE,
            target.ADLS_PATHS = source.ADLS_PATHS,
            target.OBJECT_PARAMETERS = source.OBJECT_PARAMETERS
    WHEN NOT MATCHED THEN
        INSERT (OBJECT_NAME, OBJECT_TYPE, PIPELINE_NAME, TRIGGERS_INFO, BATCH_FREQUENCY, LOAD_TYPE, ADLS_PATHS, OBJECT_PARAMETERS)
        VALUES (source.OBJECT_NAME, source.OBJECT_TYPE, source.PIPELINE_NAME, source.TRIGGERS_INFO, source.BATCH_FREQUENCY, source.LOAD_TYPE, source.ADLS_PATHS, source.OBJECT_PARAMETERS);
END;